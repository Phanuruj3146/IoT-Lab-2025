import RPi.GPIO as GPIO
import time
import paho.mqtt.client as mqtt
import threading

# ---------------- GPIO Pins ----------------
TRIG = 4
ECHO = 17
RED = 27
YELLOW = 24
GREEN = 22

# ---------------- MQTT Settings ----------------
BROKER = "broker.hivemq.com"  # Public broker
PORT = 1883
TOPIC_CONTROL = "ultrasonic/control"
TOPIC_DATA = "ultrasonic/data"

running = False  # Flag for sensor loop

# ---------------- GPIO Setup ----------------
GPIO.setmode(GPIO.BCM)
GPIO.setup(TRIG, GPIO.OUT)
GPIO.setup(ECHO, GPIO.IN)
GPIO.setup(RED, GPIO.OUT)
GPIO.setup(YELLOW, GPIO.OUT)
GPIO.setup(GREEN, GPIO.OUT)
GPIO.output(TRIG, False)

# ---------------- Ultrasonic Function ----------------
def get_distance():
    # Trigger ultrasonic
    GPIO.output(TRIG, True)
    time.sleep(0.00001)
    GPIO.output(TRIG, False)

    while GPIO.input(ECHO) == 0:
        pulse_start = time.time()

    while GPIO.input(ECHO) == 1:
        pulse_end = time.time()

    pulse_duration = pulse_end - pulse_start
    distance = pulse_duration * 34300 / 2
    return round(distance, 2)

# ---------------- LED Control ----------------
def set_lights(distance):
    if distance is None:
        # Turn off all if no reading
        GPIO.output(RED, False)
        GPIO.output(YELLOW, False)
        GPIO.output(GREEN, False)
    elif distance < 10:
        GPIO.output(RED, True)
        GPIO.output(YELLOW, False)
        GPIO.output(GREEN, False)
    elif 10 <= distance <= 30:
        GPIO.output(RED, False)
        GPIO.output(YELLOW, True)
        GPIO.output(GREEN, False)
    else:
        GPIO.output(RED, False)
        GPIO.output(YELLOW, False)
        GPIO.output(GREEN, True)

# ---------------- Sensor Loop ----------------
def sensor_loop(client):
    global running
    while running:
        dist = get_distance()
        set_lights(dist)
        if dist is not None:
            client.publish(TOPIC_DATA, str(dist))
        else:
            client.publish(TOPIC_DATA, "No Reading")
        time.sleep(1)

# ---------------- MQTT Callbacks ----------------
def on_connect(client, userdata, flags, rc):
    print("Connected with result code", rc)
    client.subscribe(TOPIC_CONTROL)

def on_message(client, userdata, msg):
    global running
    payload = msg.payload.decode()
    print("Received:", payload)

    if payload == "ON" and not running:
        running = True
        threading.Thread(target=sensor_loop, args=(client,), daemon=True).start()
    elif payload == "OFF":
        running = False
        # Turn off LEDs immediately
        GPIO.output(RED, False)
        GPIO.output(YELLOW, False)
        GPIO.output(GREEN, False)

# ---------------- MQTT Setup ----------------
client = mqtt.Client()
client.on_connect = on_connect
client.on_message = on_message
client.connect(BROKER, PORT, 60)

# ---------------- Main ----------------
try:
    client.loop_forever()
except KeyboardInterrupt:
    print("Stopped by user")
finally:
    GPIO.cleanup()
